import "./chunk-NZXBYJYQ.js";
import {
  O
} from "./chunk-KLPS7OE4.js";
import {
  require_jsx_runtime
} from "./chunk-VXCDF2R5.js";
import {
  require_react_dom
} from "./chunk-6I5JPKR6.js";
import {
  require_react
} from "./chunk-76T5642S.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// ../node_modules/@semoss/sdk-react/dist/index.js
var import_react = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react_dom = __toESM(require_react_dom());
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var InsightContext = (0, import_react.createContext)(void 0);
var InsightProvider = (props) => {
  const { children, options } = props;
  const insight = (0, import_react.useMemo)(() => {
    return new O();
  }, []);
  const [isInitialized, setIsInitialized] = (0, import_react.useState)(false);
  const [isAuthorized, setIsAuthorized] = (0, import_react.useState)(false);
  const [isReady, setIsReady] = (0, import_react.useState)(false);
  const [error, setError] = (0, import_react.useState)(null);
  const [system, setSystem] = (0, import_react.useState)(null);
  const [insightId, setInsightId] = (0, import_react.useState)("");
  const syncInsight = () => __awaiter(void 0, void 0, void 0, function* () {
    (0, import_react_dom.unstable_batchedUpdates)(() => {
      setError(insight.error);
      setSystem(insight.system);
      setIsAuthorized(insight.isAuthorized);
      setIsInitialized(insight.isInitialized);
      setIsReady(insight.isReady);
      setInsightId(insight.insightId);
    });
  });
  const wrappedActions = (0, import_react.useMemo)(() => {
    return Object.keys(insight.actions).reduce((acc, val) => {
      acc[val] = (...args) => __awaiter(void 0, void 0, void 0, function* () {
        const response = yield insight.actions[val].apply(null, [
          ...args
        ]);
        syncInsight();
        return response;
      });
      return acc;
    }, {});
  }, [insight, insight.actions]);
  (0, import_react.useEffect)(() => {
    insight.initialize(options).finally(() => {
      syncInsight();
    });
    return () => {
      insight.destroy().finally(() => {
        syncInsight();
      });
    };
  }, [insight, options]);
  return (0, import_jsx_runtime.jsx)(InsightContext.Provider, Object.assign({ value: {
    isInitialized,
    isAuthorized,
    isReady,
    error,
    system,
    actions: wrappedActions,
    insightId
  } }, { children }));
};
var useInsight = () => {
  const context = (0, import_react.useContext)(InsightContext);
  if (context === void 0) {
    throw new Error("useInsight must be used within InsightProvider");
  }
  return context;
};
export {
  InsightProvider,
  useInsight
};
//# sourceMappingURL=@semoss_sdk-react.js.map
